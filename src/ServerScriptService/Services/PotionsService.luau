--[[
	PotionsService - Manages potion inventory and temporary potion effects for players
	
	Potions can be:
	- Collected into inventory (Potions table in data store)
	- Consumed from inventory to activate a timed effect (ConsumedPotions table)
	
	Active potion effects affect:
	- Probabilities of egg hatches
	- Total distance generated by fuel (and all other multipliers)
	
	Usage pattern (similar to MonetizationService):
	- PotionsService:HasPotionEffect(player, potionName) :: boolean
	- PotionsService:GetPotionInventory(player) :: { { PotionKey: string, Quantity: number } }
	- PotionsService:AddPotionToInventory(player, potionName, quantity) :: boolean
	- PotionsService:ConsumePotion(player, potionName) :: boolean
	- PotionsService.Potions contains all potion definitions
]]

local DataService
local NotificationService
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Knit = require(ReplicatedStorage.Packages.Knit)

local PotionsService = Knit.CreateService({
	Name = "PotionsService",
	Client = {
		HasActivePotion = Knit.CreateSignal(),
		GetRemainingTime = Knit.CreateSignal(),
	},
})

-- Type definitions
export type Potion = {
	Name: string,
	UsedAt: number,
	Expiry: number, -- if 0 then infinite, no expiry
}

export type PotionDefinition = {
	Name: string,
	Duration: number,
	Multiplier: number,
	ProbabilityKey: string?, -- The probability field to use from pet config (e.g., "LuckProbability")
}

-- Active potions per player (runtime state, from ConsumedPotions)
local ActivePotions: {[Player]: {[string]: Potion}} = {}

-- Potion inventory per player (runtime cache, synced with Potions data store)
-- { [Player]: { [potionKey]: number (quantity) } }
local PotionInventories: {[Player]: {[string]: number}} = {}

-- Potion definitions with their effects
-- Note: For SuperLuck potion, we use LuckProbability from Stats to match the Luck gamepass behavior
local PotionDefinitions: {[string]: PotionDefinition} = {
	SuperLuck = {
		Name = "Super Luck Potion",
		Duration = 15 * 60, -- 15 minutes in seconds
		Multiplier = 1.0, -- No fuel multiplier, just affects egg probabilities
		ProbabilityKey = "LuckProbability", -- Use Luck probability from Stats definitions
	},
	
	FuelBoost = {
		Name = "Fuel Boost Potion",
		Duration = 10 * 60, -- 10 minutes
		Multiplier = 1.5, -- 50% more fuel distance
		ProbabilityKey = nil, -- Does not affect egg probabilities
	},
	
	PointsOverload = {
		Name = "Points Overload Potion",
		Duration = 10 * 60, -- 10 minutes in seconds
		Multiplier = 3.0, -- x3 multiplier applied to total distance in track runs
		ProbabilityKey = nil, -- Does not affect egg probabilities
	},

	MagnetPulse = {
		Name = "Magnet Pulse Potion",
		Duration = 10 * 60, -- 10 minutes in seconds
		Multiplier = 1.0, -- No distance multiplier, just affects star collection range
		ProbabilityKey = nil, -- Does not affect egg probabilities
	},
}

-- Expose Potions table for both server and client usage (like MonetizationService.Passes)
PotionsService.Potions = PotionDefinitions

-- Helper function to get potion definition
local function GetPotionDefinition(potionName: string): PotionDefinition?
	return PotionDefinitions[potionName]
end

-- Check if a potion is currently active (not expired)
local function IsPotionActive(potionData: Potion, definition: PotionDefinition): boolean
	local currentTime = os.time()
	
	-- If UsedAt == 0, potion hasn't been activated yet
	if potionData.UsedAt == 0 then
		return false
	end
	
	-- If no expiry (permanent), always active
	if potionData.Expiry == 0 then
		return true
	end
	
	-- Check if expired
	local timeElapsed = currentTime - potionData.UsedAt
	return timeElapsed < potionData.Expiry
end

-- Process expired potions for a single player
local function ProcessPlayerPotionExpiry(player: Player)
	if not ActivePotions[player] then
		return
	end
	
	local expiredPotions = {}
	
	for potionName, potionData in pairs(ActivePotions[player]) do
		local definition = GetPotionDefinition(potionName)
		if definition and not IsPotionActive(potionData, definition) then
			table.insert(expiredPotions, potionName)
		end
	end
	
	-- Remove expired potions and notify player
	for _, potionName in ipairs(expiredPotions) do
		ActivePotions[player][potionName] = nil
		
		if player and player.Parent then
			NotificationService:SendNotification(player, {
				Title = "Potion Expired",
				Message = potionName .. " has worn off!",
				Type = "Warning",
			})
		end
	end
	
	-- Fire data ready to update UI if any potions expired
	if #expiredPotions > 0 and player and player.Parent then
		DataService:FireDataReady(player)
	end
end

-- Initialize consumed (active) potions for a player from their saved data
function PotionsService:InitializePotions(player: Player, potionsData: {Potion}?)
	if not potionsData then
		ActivePotions[player] = {}
		return
	end
	
	ActivePotions[player] = {}
	
	for _, potionData in ipairs(potionsData) do
		local definition = GetPotionDefinition(potionData.Name)
		if definition then
			-- Combine saved data with definition
			local combinedPotion: Potion = {
				Name = potionData.Name,
				UsedAt = potionData.UsedAt or 0,
				Expiry = potionData.Expiry or definition.Duration,
			}
			
			-- Check if potion is still active
			if IsPotionActive(combinedPotion, definition) then
				ActivePotions[player][potionData.Name] = combinedPotion
			end
		end
	end
end

--[[
	Initialize potion inventory for a player from their saved data.
	Called during session setup alongside InitializePotions.
	
	@param player Player - The player
	@param inventoryData {{PotionKey: string, Quantity: number}}? - Saved inventory entries
]]
function PotionsService:InitializePotionInventory(player: Player, inventoryData: {{PotionKey: string, Quantity: number}}?)
	PotionInventories[player] = {}
	
	if not inventoryData then
		return
	end
	
	for _, entry in ipairs(inventoryData) do
		local definition = GetPotionDefinition(entry.PotionKey)
		if definition and entry.Quantity and entry.Quantity > 0 then
			PotionInventories[player][entry.PotionKey] = entry.Quantity
		end
	end
end

-- Directly activate a potion effect (bypasses inventory, used by dev products / boss rewards)
function PotionsService:AddPotion(player: Player, potionName: string): boolean
	local definition = GetPotionDefinition(potionName)
	if not definition then
		warn("Unknown potion: " .. potionName)
		return false
	end
	
	-- Initialize player's potions if needed
	if not ActivePotions[player] then
		ActivePotions[player] = {}
	end
	
	-- Create potion data
	local currentTime = os.time()
	local potionData: Potion = {
		Name = potionName,
		UsedAt = currentTime,
		Expiry = definition.Duration,
	}
	
	-- Add to active potions
	ActivePotions[player][potionName] = potionData
	
	-- Send notification
	NotificationService:SendNotification(
		player,
		definition.Name .. " potion is now active!",
		NotificationService.Category.Success
	)
	
	-- Save to datastore
	self:SavePotions(player)
	
	-- Fire data ready to update UI
	DataService:FireDataReady(player)
	
	return true
end

--------------------------------------------------------------------------------
-- Potion Inventory (collectible potions)
--------------------------------------------------------------------------------

--[[
	Add potions to a player's inventory (collectible, not yet consumed).
	
	@param player Player - The player
	@param potionName string - The potion key (must exist in PotionDefinitions)
	@param quantity number? - Amount to add (defaults to 1)
	@return boolean - True if added successfully
]]
function PotionsService:AddPotionToInventory(player: Player, potionName: string, quantity: number?): boolean
	local definition = GetPotionDefinition(potionName)
	if not definition then
		warn("[PotionsService]: Unknown potion: " .. potionName)
		return false
	end
	
	local amount = quantity or 1
	if amount <= 0 then
		return false
	end
	
	if not PotionInventories[player] then
		PotionInventories[player] = {}
	end
	
	PotionInventories[player][potionName] = (PotionInventories[player][potionName] or 0) + amount
	
	-- Persist to data store
	self:SavePotionInventory(player)
	
	-- Notify client
	NotificationService:SendNotification(
		player,
		"Received " .. amount .. "x " .. definition.Name .. "!",
		NotificationService.Category.Success
	)
	
	-- Sync client data
	DataService:FireDataReady(player)
	
	return true
end

--[[
	Consume a potion from the player's inventory to activate its effect.
	Decrements quantity by 1 and activates the potion effect (same as AddPotion).
	
	@param player Player - The player
	@param potionName string - The potion key to consume
	@return boolean, string? - Success flag and optional error message
]]
function PotionsService:ConsumePotion(player: Player, potionName: string): (boolean, string?)
	local definition = GetPotionDefinition(potionName)
	if not definition then
		return false, "Unknown potion: " .. potionName
	end
	
	-- Check inventory
	local inventory = PotionInventories[player]
	if not inventory or not inventory[potionName] or inventory[potionName] <= 0 then
		return false, "You don't have any " .. definition.Name .. " to use."
	end
	
	-- Check if this potion type is already active
	if self:HasPotionEffect(player, potionName) then
		return false, definition.Name .. " is already active!"
	end
	
	-- Decrement inventory
	inventory[potionName] = inventory[potionName] - 1
	if inventory[potionName] <= 0 then
		inventory[potionName] = nil
	end
	
	-- Activate the potion effect (reuse existing activation logic)
	if not ActivePotions[player] then
		ActivePotions[player] = {}
	end
	
	local currentTime = os.time()
	ActivePotions[player][potionName] = {
		Name = potionName,
		UsedAt = currentTime,
		Expiry = definition.Duration,
	}
	
	NotificationService:SendNotification(
		player,
		definition.Name .. " is now active!",
		NotificationService.Category.Success
	)
	
	-- Save both consumed and inventory
	self:SavePotions(player)
	self:SavePotionInventory(player)

	task.delay(0.5, function()
		DataService:FireDataReady(player)
	end)
	
	return true, nil
end

--[[
	Get the player's potion inventory as an array (for client/serialization).
	
	@param player Player - The player
	@return { { PotionKey: string, Quantity: number } }
]]
function PotionsService:GetPotionInventory(player: Player): {{PotionKey: string, Quantity: number}}
	local result = {}
	local inventory = PotionInventories[player]
	if not inventory then
		return result
	end
	
	for potionKey, qty in pairs(inventory) do
		if qty > 0 then
			table.insert(result, { PotionKey = potionKey, Quantity = qty })
		end
	end
	
	return result
end

--[[
	Get the quantity of a specific potion in the player's inventory.
	
	@param player Player - The player
	@param potionName string - The potion key
	@return number - Quantity owned (0 if none)
]]
function PotionsService:GetPotionQuantity(player: Player, potionName: string): number
	local inventory = PotionInventories[player]
	if not inventory then
		return 0
	end
	return inventory[potionName] or 0
end

-- Save potion inventory to data store
function PotionsService:SavePotionInventory(player: Player)
	local inventoryArray = self:GetPotionInventory(player)
	
	DataService:Update(player, "Inventory", function(inventory)
		inventory.Potions = inventoryArray
		return inventory
	end)
end

--[[
	Check if player has a specific potion effect active.
	This is the primary method other scripts should use to check potion status.
	
	@param player Player - The player to check
	@param potionName string - The name of the potion (e.g., "SuperLuck", "FuelBoost")
	@return boolean - True if the potion effect is currently active
]]
function PotionsService:HasPotionEffect(player: Player, potionName: string): boolean
	if not ActivePotions[player] then
		return false
	end
	
	local potionData = ActivePotions[player][potionName]
	if not potionData then
		return false
	end
	
	local definition = GetPotionDefinition(potionName)
	if not definition then
		return false
	end
	
	return IsPotionActive(potionData, definition)
end

-- Check if player has an active potion (returns potion data)
function PotionsService:GetActivePotion(player: Player, potionName: string): Potion?
	if not self:HasPotionEffect(player, potionName) then
		return nil
	end
	
	return ActivePotions[player][potionName]
end





--[[
	Get the potion definition for a given potion name.
	Useful for other scripts to access potion configuration.
	
	@param potionName string - The name of the potion
	@return PotionDefinition? - The potion definition or nil if not found
]]
function PotionsService:GetPotionDefinition(potionName: string): PotionDefinition?
	return GetPotionDefinition(potionName)
end

-- Get all active potions for a player (for saving)
function PotionsService:GetActivePotions(player: Player): {Potion}
	local potions = {}
	
	if ActivePotions[player] then
		for _, potionData in pairs(ActivePotions[player]) do
			table.insert(potions, potionData)
		end
	end
	
	return potions
end

-- Get remaining time for a potion
function PotionsService:GetRemainingTime(player: Player, potionName: string): number
	local potion = self:GetActivePotion(player, potionName)
	if not potion then
		warn("No potion found for player:", player, "potionName:", potionName)
		return 0
	end
	
	if potion.Expiry == 0 then
		return -1 -- Infinite
	end
	
	local currentTime = os.time()
	local expiresAt = potion.UsedAt + potion.Expiry
	local remaining = expiresAt - currentTime
	
	return math.max(0, remaining)
end

-- Save potions to datastore
function PotionsService:SavePotions(player: Player)
	local potions = self:GetActivePotions(player)
	
	DataService:Update(player, "Inventory", function(inventory)
		inventory.ConsumedPotions = potions
		return inventory
	end)
end

-- Get all active potions for a player (for client UI)
function PotionsService:GetPlayerPotions(player: Player): {[string]: Potion}
	if not ActivePotions[player] then
		return {}
	end
	
	-- Filter to only active potions
	local activePotions = {}
	for potionName, potionData in pairs(ActivePotions[player]) do
		local definition = GetPotionDefinition(potionName)
		if definition and IsPotionActive(potionData, definition) then
			activePotions[potionName] = potionData
		end
	end
	
	return activePotions
end

-- Client function to check if player has a potion effect (generic method)
function PotionsService.Client:HasPotionEffect(player: Player, potionName: string): boolean
	return PotionsService:HasPotionEffect(player, potionName)
end

-- Client function to check if player has active potion (legacy compatibility)
function PotionsService.Client:HasActivePotion(player: Player, potionName: string): boolean
	return PotionsService:HasPotionEffect(player, potionName)
end



-- Client function to get remaining time for a potion
function PotionsService.Client:GetRemainingTime(player: Player, potionName: string): number
	return PotionsService:GetRemainingTime(player, potionName)
end

-- Client function to get all active potions for the player
function PotionsService.Client:GetPlayerPotions(player: Player): {[string]: Potion}
	return PotionsService:GetPlayerPotions(player)
end

-- Client function to get potion inventory
function PotionsService.Client:GetPotionInventory(player: Player): {{PotionKey: string, Quantity: number}}
	return PotionsService:GetPotionInventory(player)
end

-- Client function to consume a potion from inventory
function PotionsService.Client:ConsumePotion(player: Player, potionName: string): (boolean, string?)
	return PotionsService:ConsumePotion(player, potionName)
end

function PotionsService:KnitInit()
	Knit = require(game.ReplicatedStorage.Packages.Knit)
end

function PotionsService:KnitStart()
	DataService = Knit.GetService("DataService")
	NotificationService = Knit.GetService("NotificationService")
	
	-- Single central RunService loop to check all player potions for expiry
	-- This replaces individual Heartbeat connections per player/potion
	-- Only check once per second to avoid excessive processing
	local lastCheckTime = 0
	local CHECK_INTERVAL = 1 -- Check every 1 second
	
	RunService.Heartbeat:Connect(function()
		local currentTime = os.time()
		if currentTime - lastCheckTime < CHECK_INTERVAL then
			return
		end
		lastCheckTime = currentTime
		
		for _, player in ipairs(Players:GetPlayers()) do
			ProcessPlayerPotionExpiry(player)
		end
	end)
	
	-- Clean up when player leaves
	Players.PlayerRemoving:Connect(function(player)
		-- Save potions before cleanup
		self:SavePotions(player)
		self:SavePotionInventory(player)
		
		-- Clean up runtime state
		ActivePotions[player] = nil
		PotionInventories[player] = nil
	end)
end

return PotionsService
