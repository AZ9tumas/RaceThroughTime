--[[
	PotionsService - Manages temporary and permanent potion effects for players
	
	Potions affect:
	- Probabilities of egg hatches
	- Total distance generated by fuel (and all other multipliers)
	
	Usage pattern (similar to MonetizationService):
	- PotionsService:HasPotionEffect(player, potionName) :: boolean
	- PotionsService.Potions contains all potion definitions
]]

local DataService
local NotificationService
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Knit = require(ReplicatedStorage.Packages.Knit)

local PotionsService = Knit.CreateService({
	Name = "PotionsService",
	Client = {
		HasActivePotion = Knit.CreateSignal(),
		GetProbabilityKey = Knit.CreateSignal(),
		GetPotionMultiplier = Knit.CreateSignal(),
		GetRemainingTime = Knit.CreateSignal(),
	},
})

-- Type definitions
export type Potion = {
	Name: string,
	UsedAt: number,
	Expiry: number, -- if 0 then infinite, no expiry
}

export type PotionDefinition = {
	Name: string,
	Duration: number,
	Multiplier: number,
	ProbabilityKey: string?, -- The probability field to use from pet config (e.g., "LuckProbability")
}

-- Active potions per player (runtime state)
local ActivePotions: {[Player]: {[string]: Potion}} = {}

-- Potion definitions with their effects
-- Note: For SuperLuck potion, we use LuckProbability from Stats to match the Luck gamepass behavior
local PotionDefinitions: {[string]: PotionDefinition} = {
	SuperLuck = {
		Name = "Super Luck Potion",
		Duration = 15 * 60, -- 15 minutes in seconds
		Multiplier = 1.0, -- No fuel multiplier, just affects egg probabilities
		ProbabilityKey = "LuckProbability", -- Use Luck probability from Stats definitions
	},
	
	FuelBoost = {
		Name = "Fuel Boost Potion",
		Duration = 10 * 60, -- 10 minutes
		Multiplier = 1.5, -- 50% more fuel distance
		ProbabilityKey = nil, -- Does not affect egg probabilities
	},
	
	PointsOverload = {
		Name = "Points Overload Potion",
		Duration = 10 * 60, -- 10 minutes in seconds
		Multiplier = 3.0, -- x3 the total distance produced from fuel
		ProbabilityKey = nil, -- Does not affect egg probabilities
	},
}

-- Expose Potions table for both server and client usage (like MonetizationService.Passes)
PotionsService.Potions = PotionDefinitions

-- Helper function to get potion definition
local function GetPotionDefinition(potionName: string): PotionDefinition?
	return PotionDefinitions[potionName]
end

-- Check if a potion is currently active (not expired)
local function IsPotionActive(potionData: Potion, definition: PotionDefinition): boolean
	local currentTime = os.time()
	
	-- If UsedAt == 0, potion hasn't been activated yet
	if potionData.UsedAt == 0 then
		return false
	end
	
	-- If no expiry (permanent), always active
	if potionData.Expiry == 0 then
		return true
	end
	
	-- Check if expired
	local timeElapsed = currentTime - potionData.UsedAt
	return timeElapsed < potionData.Expiry
end

-- Process expired potions for a single player
local function ProcessPlayerPotionExpiry(player: Player)
	if not ActivePotions[player] then
		return
	end
	
	local expiredPotions = {}
	
	for potionName, potionData in pairs(ActivePotions[player]) do
		local definition = GetPotionDefinition(potionName)
		if definition and not IsPotionActive(potionData, definition) then
			table.insert(expiredPotions, potionName)
		end
	end
	
	-- Remove expired potions and notify player
	for _, potionName in ipairs(expiredPotions) do
		ActivePotions[player][potionName] = nil
		
		if player and player.Parent then
			NotificationService:SendNotification(player, {
				Title = "Potion Expired",
				Message = potionName .. " has worn off!",
				Type = "Warning",
			})
		end
	end
	
	-- Fire data ready to update UI if any potions expired
	if #expiredPotions > 0 and player and player.Parent then
		DataService:FireDataReady(player)
	end
end

-- Initialize potions for a player from their saved data
function PotionsService:InitializePotions(player: Player, potionsData: {Potion}?)
	if not potionsData then
		ActivePotions[player] = {}
		return
	end
	
	ActivePotions[player] = {}
	
	for _, potionData in ipairs(potionsData) do
		local definition = GetPotionDefinition(potionData.Name)
		if definition then
			-- Combine saved data with definition
			local combinedPotion: Potion = {
				Name = potionData.Name,
				UsedAt = potionData.UsedAt or 0,
				Expiry = potionData.Expiry or definition.Duration,
			}
			
			-- Check if potion is still active
			if IsPotionActive(combinedPotion, definition) then
				ActivePotions[player][potionData.Name] = combinedPotion
			end
		end
	end
end

-- Add a new potion to player
function PotionsService:AddPotion(player: Player, potionName: string): boolean
	local definition = GetPotionDefinition(potionName)
	if not definition then
		warn("Unknown potion: " .. potionName)
		return false
	end
	
	-- Initialize player's potions if needed
	if not ActivePotions[player] then
		ActivePotions[player] = {}
	end
	
	-- Create potion data
	local currentTime = os.time()
	local potionData: Potion = {
		Name = potionName,
		UsedAt = currentTime,
		Expiry = definition.Duration,
	}
	
	-- Add to active potions
	ActivePotions[player][potionName] = potionData
	
	-- Send notification
	NotificationService:SendNotification(player, {
		Title = "Potion Activated",
		Message = definition.Name .. " is now active!",
		Type = "Success",
	})
	
	-- Save to datastore
	self:SavePotions(player)
	
	-- Fire data ready to update UI
	DataService:FireDataReady(player)
	
	return true
end

--[[
	Check if player has a specific potion effect active.
	This is the primary method other scripts should use to check potion status.
	
	@param player Player - The player to check
	@param potionName string - The name of the potion (e.g., "SuperLuck", "FuelBoost")
	@return boolean - True if the potion effect is currently active
]]
function PotionsService:HasPotionEffect(player: Player, potionName: string): boolean
	if not ActivePotions[player] then
		return false
	end
	
	local potionData = ActivePotions[player][potionName]
	if not potionData then
		return false
	end
	
	local definition = GetPotionDefinition(potionName)
	if not definition then
		return false
	end
	
	return IsPotionActive(potionData, definition)
end

-- Check if player has an active potion (returns potion data)
function PotionsService:GetActivePotion(player: Player, potionName: string): Potion?
	if not self:HasPotionEffect(player, potionName) then
		return nil
	end
	
	return ActivePotions[player][potionName]
end

--[[
	Check if player has any active potion that affects probabilities.
	Returns the probability key to use from pet config.
	
	@param player Player - The player to check
	@return (boolean, string?) - Whether they have a probability potion and which key to use
]]
function PotionsService:HasProbabilityPotion(player: Player): (boolean, string?)
	if not ActivePotions[player] then
		return false, nil
	end
	
	for potionName, potionData in pairs(ActivePotions[player]) do
		local definition = GetPotionDefinition(potionName)
		if definition and definition.ProbabilityKey then
			if IsPotionActive(potionData, definition) then
				return true, definition.ProbabilityKey
			end
		end
	end
	
	return false, nil
end

-- Get the fuel multiplier from all active potions
function PotionsService:GetPotionMultiplier(player: Player, potionName: string?): number
	if not ActivePotions[player] then
		return 1.0
	end
	
	-- If specific potion requested
	if potionName then
		local potionData = ActivePotions[player][potionName]
		if potionData then
			local definition = GetPotionDefinition(potionName)
			if definition and IsPotionActive(potionData, definition) then
				return definition.Multiplier or 1.0
			end
		end
		return 1.0
	end
	
	-- Get combined multiplier from all active potions
	local totalMultiplier = 1.0
	for pName, potionData in pairs(ActivePotions[player]) do
		local definition = GetPotionDefinition(pName)
		if definition and definition.Multiplier and IsPotionActive(potionData, definition) then
			totalMultiplier = totalMultiplier * definition.Multiplier
		end
	end
	
	return totalMultiplier
end

--[[
	Get the potion definition for a given potion name.
	Useful for other scripts to access potion configuration.
	
	@param potionName string - The name of the potion
	@return PotionDefinition? - The potion definition or nil if not found
]]
function PotionsService:GetPotionDefinition(potionName: string): PotionDefinition?
	return GetPotionDefinition(potionName)
end

-- Get all active potions for a player (for saving)
function PotionsService:GetActivePotions(player: Player): {Potion}
	local potions = {}
	
	if ActivePotions[player] then
		for _, potionData in pairs(ActivePotions[player]) do
			table.insert(potions, potionData)
		end
	end
	
	return potions
end

-- Get remaining time for a potion
function PotionsService:GetRemainingTime(player: Player, potionName: string): number
	local potion = self:GetActivePotion(player, potionName)
	if not potion then
		return 0
	end
	
	if potion.Expiry == 0 then
		return -1 -- Infinite
	end
	
	local currentTime = os.time()
	local expiresAt = potion.UsedAt + potion.Expiry
	local remaining = expiresAt - currentTime
	
	return math.max(0, remaining)
end

-- Save potions to datastore
function PotionsService:SavePotions(player: Player)
	local potions = self:GetActivePotions(player)
	local playerData = DataService:Get(player)
	
	if playerData then
		playerData.Potions = potions
	end
end

-- Get all active potions for a player (for client UI)
function PotionsService:GetPlayerPotions(player: Player): {[string]: Potion}
	if not ActivePotions[player] then
		return {}
	end
	
	-- Filter to only active potions
	local activePotions = {}
	for potionName, potionData in pairs(ActivePotions[player]) do
		local definition = GetPotionDefinition(potionName)
		if definition and IsPotionActive(potionData, definition) then
			activePotions[potionName] = potionData
		end
	end
	
	return activePotions
end

-- Client function to check if player has a potion effect (generic method)
function PotionsService.Client:HasPotionEffect(player: Player, potionName: string): boolean
	return PotionsService:HasPotionEffect(player, potionName)
end

-- Client function to check if player has active potion (legacy compatibility)
function PotionsService.Client:HasActivePotion(player: Player, potionName: string): boolean
	return PotionsService:HasPotionEffect(player, potionName)
end

-- Client function to get probability key if potion affects it
function PotionsService.Client:GetProbabilityKey(player: Player): string?
	local hasPotion, probabilityKey = PotionsService:HasProbabilityPotion(player)
	if hasPotion then
		return probabilityKey
	end
	return nil
end

-- Client function to get potion multiplier
function PotionsService.Client:GetPotionMultiplier(player: Player): number
	return PotionsService:GetPotionMultiplier(player)
end

-- Client function to get remaining time for a potion
function PotionsService.Client:GetRemainingTime(player: Player, potionName: string): number
	return PotionsService:GetRemainingTime(player, potionName)
end

-- Client function to get all active potions for the player
function PotionsService.Client:GetPlayerPotions(player: Player): {[string]: Potion}
	return PotionsService:GetPlayerPotions(player)
end

function PotionsService:KnitInit()
	Knit = require(game.ReplicatedStorage.Packages.Knit)
end

function PotionsService:KnitStart()
	DataService = Knit.GetService("DataService")
	NotificationService = Knit.GetService("NotificationService")
	
	-- Single central RunService loop to check all player potions for expiry
	-- This replaces individual Heartbeat connections per player/potion
	-- Only check once per second to avoid excessive processing
	local lastCheckTime = 0
	local CHECK_INTERVAL = 1 -- Check every 1 second
	
	RunService.Heartbeat:Connect(function()
		local currentTime = os.time()
		if currentTime - lastCheckTime < CHECK_INTERVAL then
			return
		end
		lastCheckTime = currentTime
		
		for _, player in ipairs(Players:GetPlayers()) do
			ProcessPlayerPotionExpiry(player)
		end
	end)
	
	-- Clean up when player leaves
	Players.PlayerRemoving:Connect(function(player)
		-- Save potions before cleanup
		self:SavePotions(player)
		
		-- Clean up active potions
		ActivePotions[player] = nil
	end)
end

return PotionsService
