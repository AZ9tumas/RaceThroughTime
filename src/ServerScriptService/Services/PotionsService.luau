--[[
	PotionsService - Manages temporary and permanent potion effects for players
	
	Potions affect:
	- Probabilities of egg hatches
	- Total distance generated by fuel (and all other multipliers)
]]

local PotionsService = {
	Name = "PotionsService",
	Client = {},
}

local Knit
local DataService
local NotificationService
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

-- Type definitions
export type Potion = {
	Name: string,
	UsedAt: number,
	Expiry: number, -- if 0 then infinite, no expiry
}

-- Active potions per player (runtime state)
local ActivePotions: {[Player]: {[string]: Potion}} = {}

-- Expiry check connections per player per potion
local ExpiryConnections: {[Player]: {[string]: RBXScriptConnection}} = {}

-- Potion definitions with their effects
local PotionDefinitions = {
	SuperLuck = {
		Name = "Super Luck Potion",
		Duration = 15 * 60, -- 15 minutes in seconds
		Multiplier = 1.0, -- No fuel multiplier, just affects egg probabilities
		ProbabilityKey = "PotionProbability", -- Use this probability field from pet config
		
		UsePotion = function(self, player: Player, potionData: Potion)
			-- This is activated for only 15 mins after obtaining
			local currentTime = os.time()
			
			-- If UsedAt == 0, set it to current time (first use)
			if potionData.UsedAt == 0 then
				potionData.UsedAt = currentTime
			end
			
			-- Check if expired
			local timeElapsed = currentTime - potionData.UsedAt
			if potionData.Expiry > 0 and timeElapsed >= potionData.Expiry then
				return false -- Potion has expired
			end
			
			-- Potion is active
			return true
		end,
	},
	
	FuelBoost = {
		Name = "Fuel Boost Potion",
		Duration = 10 * 60, -- 10 minutes
		Multiplier = 1.5, -- 50% more fuel distance
		ProbabilityKey = nil, -- Does not affect egg probabilities
		
		UsePotion = function(self, player: Player, potionData: Potion)
			local currentTime = os.time()
			
			if potionData.UsedAt == 0 then
				potionData.UsedAt = currentTime
			end
			
			local timeElapsed = currentTime - potionData.UsedAt
			if potionData.Expiry > 0 and timeElapsed >= potionData.Expiry then
				return false
			end
			
			return true
		end,
	},
}

-- Helper function to get potion definition
local function GetPotionDefinition(potionName: string)
	return PotionDefinitions[potionName]
end

-- Start expiry checking for a potion
local function StartExpiryCheck(player: Player, potionName: string, potionData: Potion)
	-- Clean up existing connection if any
	if ExpiryConnections[player] and ExpiryConnections[player][potionName] then
		ExpiryConnections[player][potionName]:Disconnect()
	end
	
	-- Initialize connection table for player
	if not ExpiryConnections[player] then
		ExpiryConnections[player] = {}
	end
	
	-- If no expiry (permanent), don't set up check
	if potionData.Expiry == 0 then
		return
	end
	
	-- Calculate when potion expires
	local expiresAt = potionData.UsedAt + potionData.Expiry
	
	-- Set up RunService check
	ExpiryConnections[player][potionName] = RunService.Heartbeat:Connect(function()
		local currentTime = os.time()
		
		if currentTime >= expiresAt then
			-- Potion has expired
			if ActivePotions[player] then
				ActivePotions[player][potionName] = nil
			end
			
			-- Disconnect this check
			if ExpiryConnections[player] and ExpiryConnections[player][potionName] then
				ExpiryConnections[player][potionName]:Disconnect()
				ExpiryConnections[player][potionName] = nil
			end
			
			-- Notify player
			if player and player.Parent then
				NotificationService:SendNotification(player, {
					Title = "Potion Expired",
					Message = potionName .. " has worn off!",
					Type = "Warning",
				})
				
				-- Fire data ready to update UI
				DataService:FireDataReady(player)
			end
		end
	end)
end

-- Initialize potions for a player from their saved data
function PotionsService:InitializePotions(player: Player, potionsData: {Potion}?)
	if not potionsData then
		ActivePotions[player] = {}
		return
	end
	
	ActivePotions[player] = {}
	
	for _, potionData in ipairs(potionsData) do
		local definition = GetPotionDefinition(potionData.Name)
		if definition then
			-- Combine saved data with definition
			local combinedPotion: Potion = {
				Name = potionData.Name,
				UsedAt = potionData.UsedAt or 0,
				Expiry = potionData.Expiry or definition.Duration,
			}
			
			-- Check if potion is still active
			if definition:UsePotion(player, combinedPotion) then
				ActivePotions[player][potionData.Name] = combinedPotion
				StartExpiryCheck(player, potionData.Name, combinedPotion)
			end
		end
	end
end

-- Add a new potion to player
function PotionsService:AddPotion(player: Player, potionName: string): boolean
	local definition = GetPotionDefinition(potionName)
	if not definition then
		warn("Unknown potion: " .. potionName)
		return false
	end
	
	-- Initialize player's potions if needed
	if not ActivePotions[player] then
		ActivePotions[player] = {}
	end
	
	-- Create potion data
	local currentTime = os.time()
	local potionData: Potion = {
		Name = potionName,
		UsedAt = currentTime,
		Expiry = definition.Duration,
	}
	
	-- Add to active potions
	ActivePotions[player][potionName] = potionData
	
	-- Start using the potion immediately
	self:UsePotion(player, potionData, definition)
	
	-- Send notification
	NotificationService:SendNotification(player, {
		Title = "Potion Activated",
		Message = definition.Name .. " is now active!",
		Type = "Success",
	})
	
	-- Save to datastore
	self:SavePotions(player)
	
	-- Fire data ready to update UI
	DataService:FireDataReady(player)
	
	return true
end

-- Activate a potion effect
function PotionsService:UsePotion(player: Player, potionData: Potion, definition)
	if not definition then
		definition = GetPotionDefinition(potionData.Name)
	end
	
	if not definition then
		return false
	end
	
	-- Execute the potion's UsePotion function
	local isActive = definition:UsePotion(player, potionData)
	
	if isActive then
		-- Start expiry checking
		StartExpiryCheck(player, potionData.Name, potionData)
	end
	
	return isActive
end

-- Check if player has an active potion
function PotionsService:GetActivePotion(player: Player, potionName: string): Potion?
	if not ActivePotions[player] then
		return nil
	end
	
	local potionData = ActivePotions[player][potionName]
	if not potionData then
		return nil
	end
	
	-- Verify it's still active
	local definition = GetPotionDefinition(potionName)
	if definition and definition:UsePotion(player, potionData) then
		return potionData
	end
	
	return nil
end

-- Check if player has any active potion that affects probabilities
function PotionsService:HasProbabilityPotion(player: Player): (boolean, string?)
	if not ActivePotions[player] then
		return false, nil
	end
	
	for potionName, potionData in pairs(ActivePotions[player]) do
		local definition = GetPotionDefinition(potionName)
		if definition and definition.ProbabilityKey and definition:UsePotion(player, potionData) then
			return true, definition.ProbabilityKey
		end
	end
	
	return false, nil
end

-- Get the fuel multiplier from all active potions
function PotionsService:GetPotionMultiplier(player: Player, potionName: string?): number
	if not ActivePotions[player] then
		return 1.0
	end
	
	-- If specific potion requested
	if potionName then
		local potionData = ActivePotions[player][potionName]
		if potionData then
			local definition = GetPotionDefinition(potionName)
			if definition and definition:UsePotion(player, potionData) then
				return definition.Multiplier or 1.0
			end
		end
		return 1.0
	end
	
	-- Get combined multiplier from all active potions
	local totalMultiplier = 1.0
	for pName, potionData in pairs(ActivePotions[player]) do
		local definition = GetPotionDefinition(pName)
		if definition and definition.Multiplier and definition:UsePotion(player, potionData) then
			totalMultiplier = totalMultiplier * definition.Multiplier
		end
	end
	
	return totalMultiplier
end

-- Get all active potions for a player (for saving)
function PotionsService:GetActivePotions(player: Player): {Potion}
	local potions = {}
	
	if ActivePotions[player] then
		for _, potionData in pairs(ActivePotions[player]) do
			table.insert(potions, potionData)
		end
	end
	
	return potions
end

-- Save potions to datastore
function PotionsService:SavePotions(player: Player)
	local potions = self:GetActivePotions(player)
	local playerData = DataService:GetData(player)
	
	if playerData then
		playerData.Potions = potions
	end
end

-- Client function to check if player has active potion
function PotionsService.Client:HasActivePotion(player: Player, potionName: string): boolean
	local potion = PotionsService:GetActivePotion(player, potionName)
	return potion ~= nil
end

-- Client function to get probability key if potion affects it
function PotionsService.Client:GetProbabilityKey(player: Player): string?
	local hasPotion, probabilityKey = PotionsService:HasProbabilityPotion(player)
	if hasPotion then
		return probabilityKey
	end
	return nil
end

-- Client function to get potion multiplier
function PotionsService.Client:GetPotionMultiplier(player: Player): number
	return PotionsService:GetPotionMultiplier(player)
end

-- Client function to get remaining time for a potion
function PotionsService.Client:GetRemainingTime(player: Player, potionName: string): number
	local potion = PotionsService:GetActivePotion(player, potionName)
	if not potion then
		return 0
	end
	
	if potion.Expiry == 0 then
		return -1 -- Infinite
	end
	
	local currentTime = os.time()
	local expiresAt = potion.UsedAt + potion.Expiry
	local remaining = expiresAt - currentTime
	
	return math.max(0, remaining)
end

function PotionsService:KnitInit()
	Knit = require(game.ReplicatedStorage.Packages.Knit)
end

function PotionsService:KnitStart()
	DataService = Knit.GetService("DataService")
	NotificationService = Knit.GetService("NotificationService")
	
	-- Clean up when player leaves
	Players.PlayerRemoving:Connect(function(player)
		-- Save potions before cleanup
		self:SavePotions(player)
		
		-- Clean up expiry connections
		if ExpiryConnections[player] then
			for _, connection in pairs(ExpiryConnections[player]) do
				connection:Disconnect()
			end
			ExpiryConnections[player] = nil
		end
		
		-- Clean up active potions
		ActivePotions[player] = nil
	end)
end

return PotionsService
